<!DOCTYPE html><html>
<head><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<link rel="stylesheet" href="styles/intel_table_styles.css"></head>
<body>
<h3>Intel&reg; Microarchitecture code named Goldmont Events</h3> This section provides reference for hardware events that can be monitored for the CPU(s):<p>
<li>Intel&reg; microarchitecture code named Goldmont</li><p>
<table class="table table-responsive" style="table-layout:fixed;width:100%">
	<tr>
		<th>EventName</th>
		<th>Description</th>
	</tr>
	<tr>
		<td><span id="BACLEARS">BACLEARS</span></td>
		<td>A Branch Address Calculator Clear (BACLEAR) event occurs shortly after decoding an instruction and recognizing a branch/call/jump/ret instruction.  A BACLEAR causes the front end to restart and start fetching from a different location.  While it is similar to a branch mispredict signaled from the execute part of the pipeline, it is not counted as a BR_MISP_RETIRED event. Branch mispredicts and BACLEARS are similar in that they both restart the front end to begin instruction fetch at a new target location, and they both flush some speculative work.  However, a branch mispredict must flush partially completed instructions from front end and back end.  Since a BACLEAR occurs right at decode time, it mostly flushes bytes and not yet fully decoded instructions.  Recovery after a BACLEAR is less complicated, and faster than recovery after a branch mispredict.</td>
	</tr>
	<tr>
		<td><span id="BACLEARS.ALL">BACLEARS.ALL</span></td>
		<td>Counts the number of times a BACLEAR is signaled for any reason, including, but not limited to indirect branch/call,  Jcc (Jump on Conditional Code/Jump if Condition is Met) branch, unconditional branch/call, and returns.</td>
	</tr>
	<tr>
		<td><span id="BACLEARS.COND">BACLEARS.COND</span></td>
		<td>Counts BACLEARS on Jcc (Jump on Conditional Code/Jump if Condition is Met) branches.</td>
	</tr>
	<tr>
		<td><span id="BACLEARS.RETURN">BACLEARS.RETURN</span></td>
		<td>Counts BACLEARS on return instructions.</td>
	</tr>
	<tr>
		<td><span id="BR_INST_RETIRED">BR_INST_RETIRED</span></td>
		<td>These events measure the number of instructions in which the Instruction Pointer (IP) of the processor is resteered and the instruction successfully retired.  All branch type instructions can be counted.  *These events are Precise Event capable:  The EventingRIP field in the PEBS record is precise to the address of the instruction which caused the event.  Note: Because PEBS records can be collected only on IA32_PMC0, only one event can use the PEBS facility at a time.</td>
	</tr>
	<tr>
		<td><span id="BR_INST_RETIRED.ALL_BRANCHES">BR_INST_RETIRED.ALL_BRANCHES</span></td>
		<td>Counts branch instructions retired for all branch types.  This is an architectural performance event.</td>
	</tr>
	<tr>
		<td><span id="BR_INST_RETIRED.ALL_TAKEN_BRANCHES">BR_INST_RETIRED.ALL_TAKEN_BRANCHES</span></td>
		<td>Counts the number of taken branch instructions retired.</td>
	</tr>
	<tr>
		<td><span id="BR_INST_RETIRED.CALL">BR_INST_RETIRED.CALL</span></td>
		<td>Counts near CALL branch instructions retired.</td>
	</tr>
	<tr>
		<td><span id="BR_INST_RETIRED.FAR_BRANCH">BR_INST_RETIRED.FAR_BRANCH</span></td>
		<td>Counts far branch instructions retired.  This includes far jump, far call and return, and Interrupt call and return.</td>
	</tr>
	<tr>
		<td><span id="BR_INST_RETIRED.IND_CALL">BR_INST_RETIRED.IND_CALL</span></td>
		<td>Counts near indirect CALL branch instructions retired.</td>
	</tr>
	<tr>
		<td><span id="BR_INST_RETIRED.JCC">BR_INST_RETIRED.JCC</span></td>
		<td>Counts retired Jcc (Jump on Conditional Code/Jump if Condition is Met) branch instructions retired, including both when the branch was taken and when it was not taken.</td>
	</tr>
	<tr>
		<td><span id="BR_INST_RETIRED.NON_RETURN_IND">BR_INST_RETIRED.NON_RETURN_IND</span></td>
		<td>Counts near indirect call or near indirect jmp branch instructions retired.</td>
	</tr>
	<tr>
		<td><span id="BR_INST_RETIRED.REL_CALL">BR_INST_RETIRED.REL_CALL</span></td>
		<td>Counts near relative CALL branch instructions retired.</td>
	</tr>
	<tr>
		<td><span id="BR_INST_RETIRED.RETURN">BR_INST_RETIRED.RETURN</span></td>
		<td>Counts near return branch instructions retired.</td>
	</tr>
	<tr>
		<td><span id="BR_INST_RETIRED.TAKEN_JCC">BR_INST_RETIRED.TAKEN_JCC</span></td>
		<td>Counts Jcc (Jump on Conditional Code/Jump if Condition is Met) branch instructions retired that were taken and does not count when the Jcc branch instruction were not taken.</td>
	</tr>
	<tr>
		<td><span id="BR_MISP_RETIRED">BR_MISP_RETIRED</span></td>
		<td>Branch prediction predicts the branch target and enables the processor to begin executing instructions long before the branch true execution path is known. The branch prediction unit (BPU) is capable of predicting all possible types of branch instructions.  This unit predicts the target address not only based on the IP of the branch but also based on the execution path through which execution reached this IP.   This event counts the number of retired branch instructions that were mispredicted by the processor, categorized by type.  A branch misprediction occurs when the processor predicts that the branch will go to a particular address, but it doesn&#39;t.  When the misprediction is discovered, all the instructions executed in the wrong (speculative) path must be discarded, and the processor must start fetching from the correct path.   *These events are Precise Event capable:  The EventingRIP field in the PEBS record is precise to the address of the instruction which caused the event.  Note: Because PEBS records can be collected only on IA32_PMC0, only one event can use the PEBS facility at a time.</td>
	</tr>
	<tr>
		<td><span id="BR_MISP_RETIRED.ALL_BRANCHES">BR_MISP_RETIRED.ALL_BRANCHES</span></td>
		<td>Counts mispredicted branch instructions retired including all branch types.</td>
	</tr>
	<tr>
		<td><span id="BR_MISP_RETIRED.IND_CALL">BR_MISP_RETIRED.IND_CALL</span></td>
		<td>Counts mispredicted near indirect CALL branch instructions retired, where the target address taken was not what the processor predicted.</td>
	</tr>
	<tr>
		<td><span id="BR_MISP_RETIRED.JCC">BR_MISP_RETIRED.JCC</span></td>
		<td>Counts mispredicted retired Jcc (Jump on Conditional Code/Jump if Condition is Met) branch instructions retired, including both when the branch was supposed to be taken and when it was not supposed to be taken (but the processor predicted the opposite condition).</td>
	</tr>
	<tr>
		<td><span id="BR_MISP_RETIRED.NON_RETURN_IND">BR_MISP_RETIRED.NON_RETURN_IND</span></td>
		<td>Counts mispredicted branch instructions retired that were near indirect call or near indirect jmp, where the target address taken was not what the processor predicted.</td>
	</tr>
	<tr>
		<td><span id="BR_MISP_RETIRED.RETURN">BR_MISP_RETIRED.RETURN</span></td>
		<td>Counts mispredicted near RET branch instructions retired, where the return address taken was not what the processor predicted.</td>
	</tr>
	<tr>
		<td><span id="BR_MISP_RETIRED.TAKEN_JCC">BR_MISP_RETIRED.TAKEN_JCC</span></td>
		<td>Counts mispredicted retired Jcc (Jump on Conditional Code/Jump if Condition is Met) branch instructions retired that were supposed to be taken but the processor predicted that it would not be taken.</td>
	</tr>
	<tr>
		<td><span id="CORE_REJECT_L2Q.ALL">CORE_REJECT_L2Q.ALL</span></td>
		<td>Counts the number of demand and L1 prefetcher requests rejected by the L2Q due to a full or nearly full condition which likely indicates back pressure from L2Q. It also counts requests that would have gone directly to the XQ, but are rejected due to a full or nearly full condition, indicating back pressure from the IDI link. The L2Q may also reject transactions from a core to ensure fairness between cores, or to delay a core&#39;s dirty eviction when the address conflicts with incoming external snoops.</td>
	</tr>
	<tr>
		<td><span id="CPU_CLK_UNHALTED">CPU_CLK_UNHALTED</span></td>
		<td>These events count the number of times an oscillator increments which is used for timing and control of the electronic components of the processor.  These events only count cycles while the core is not in a halt state.   The core enters the halt state when it is running the HLT instruction.  These events are architecturally defined.  These events are commonly used as a basis for determining the amount of time the processor is executing. The core frequency events (CPU_CLK_UNHALTED.CORE and CPU_CLK_UNHALTED.CORE_P) may change over time, as required for power, heat and/or performance considerations.   For this reason the core frequency may have a changing ratio with regards to time.  The reference frequency events (CPU_CLK_UNHALTED.REF_TSC and CPU_CLK_UNHALTED.REF) are not affected by core frequency changes but counts as if the core is running at an established frequency all the time.  For this reason the reference frequency does not vary with time, but it will stop counting if the processor is halted.</td>
	</tr>
	<tr>
		<td><span id="CPU_CLK_UNHALTED.CORE">CPU_CLK_UNHALTED.CORE</span></td>
		<td>Counts the number of core cycles while the core is not in a halt state.  The core enters the halt state when it is running the HLT instruction. In mobile systems the core frequency may change from time to time. For this reason this event may have a changing ratio with regards to time.  This event uses fixed counter 1.  You cannot collect a PEBs record for this event.</td>
	</tr>
	<tr>
		<td><span id="CPU_CLK_UNHALTED.CORE_P">CPU_CLK_UNHALTED.CORE_P</span></td>
		<td>Core cycles when core is not halted.  This event uses a (_P)rogrammable general purpose performance counter.</td>
	</tr>
	<tr>
		<td><span id="CPU_CLK_UNHALTED.REF">CPU_CLK_UNHALTED.REF</span></td>
		<td>Reference cycles when core is not halted.  This event uses a programmable general purpose performance counter.</td>
	</tr>
	<tr>
		<td><span id="CPU_CLK_UNHALTED.REF_TSC">CPU_CLK_UNHALTED.REF_TSC</span></td>
		<td>Counts the number of reference cycles that the core is not in a halt state. The core enters the halt state when it is running the HLT instruction.  In mobile systems the core frequency may change from time.  This event is not affected by core frequency changes but counts as if the core is running at the maximum frequency all the time.  This event uses fixed counter 2.  You cannot collect a PEBs record for this event.</td>
	</tr>
	<tr>
		<td><span id="CYCLES_DIV_BUSY">CYCLES_DIV_BUSY</span></td>
		<td>Counts core cycles when the integer or floating point (FP) divide unit is unable to accept a new divide uop because it is busy processing a previously dispatched uop.  Divide instructions are very long latency instructions. These event will count cycles while a divide is in progress even if the Reservation Station (RS) is empty.</td>
	</tr>
	<tr>
		<td><span id="CYCLES_DIV_BUSY.ALL">CYCLES_DIV_BUSY.ALL</span></td>
		<td>Counts core cycles if either divide unit is busy.</td>
	</tr>
	<tr>
		<td><span id="CYCLES_DIV_BUSY.FPDIV">CYCLES_DIV_BUSY.FPDIV</span></td>
		<td>Counts core cycles the floating point divide unit is busy.</td>
	</tr>
	<tr>
		<td><span id="CYCLES_DIV_BUSY.IDIV">CYCLES_DIV_BUSY.IDIV</span></td>
		<td>Counts core cycles the integer divide unit is busy.</td>
	</tr>
	<tr>
		<td><span id="DECODE_RESTRICTION.PREDECODE_WRONG">DECODE_RESTRICTION.PREDECODE_WRONG</span></td>
		<td>Counts the number of times the prediction (from the predecode cache) for instruction length is incorrect.</td>
	</tr>
	<tr>
		<td><span id="DL1.DIRTY_EVICTION">DL1.DIRTY_EVICTION</span></td>
		<td>Counts when a modified (dirty) cache line is evicted from the data L1 cache and needs to be written back to memory.  No count will occur if the evicted line is clean, and hence does not require a writeback.</td>
	</tr>
	<tr>
		<td><span id="FETCH_STALL.ALL">FETCH_STALL.ALL</span></td>
		<td>Counts cycles that fetch is stalled due to any reason. That is, the decoder queue is able to accept bytes, but the fetch unit is unable to provide bytes.  This will include cycles due to an ITLB miss, ICache miss and other events. </td>
	</tr>
	<tr>
		<td><span id="FETCH_STALL.ICACHE_FILL_PENDING_CYCLES">FETCH_STALL.ICACHE_FILL_PENDING_CYCLES</span></td>
		<td>Counts cycles that fetch is stalled due to an outstanding ICache miss. That is, the decoder queue is able to accept bytes, but the fetch unit is unable to provide bytes due to an ICache miss.  Note: this event is not the same as the total number of cycles spent retrieving instruction cache lines from the memory hierarchy.</td>
	</tr>
	<tr>
		<td><span id="FETCH_STALL.ITLB_FILL_PENDING_CYCLES">FETCH_STALL.ITLB_FILL_PENDING_CYCLES</span></td>
		<td>Counts cycles that fetch is stalled due to an outstanding ITLB miss. That is, the decoder queue is able to accept bytes, but the fetch unit is unable to provide bytes due to an ITLB miss.  Note: this event is not the same as page walk cycles to retrieve an instruction translation.</td>
	</tr>
	<tr>
		<td><span id="HW_INTERRUPTS">HW_INTERRUPTS</span></td>
		<td>These Events provide information regarding Hardware (Vectored, Fixed) interrupts.  HW_INTERRUPTS.RECEIVED provides a count of the total number of Hardware Interrupts received by the processor.  This event is a straightforward count of the number of interrupts the ROB recognizes.  HW_INTERRUPTS.PENDING_AND_MASKED is the core cycles from when an interrupt arrives but the processor has masked interrupts (when the register EFLAGS.IF = 0) to when the processor no longer has masked interrupts.  Using these events in combination with PEBS can help to identify issues resulting in a system becoming unresponsive.</td>
	</tr>
	<tr>
		<td><span id="HW_INTERRUPTS.PENDING_AND_MASKED">HW_INTERRUPTS.PENDING_AND_MASKED</span></td>
		<td>Counts core cycles during which there are pending interrupts, but interrupts are masked (EFLAGS.IF = 0).</td>
	</tr>
	<tr>
		<td><span id="HW_INTERRUPTS.RECEIVED">HW_INTERRUPTS.RECEIVED</span></td>
		<td>Counts hardware interrupts received by the processor.</td>
	</tr>
	<tr>
		<td><span id="ICACHE">ICACHE</span></td>
		<td>Requests to Instruction Cache (ICache) are made in fixed sized called chunks. There are multiple chunks in a cache line, and multiple accesses might be made to a single cache line. However, the event strives to count on a cache line basis, so that multiple fetches to a single cache line count as one ICACHE.ACCESS, and either one HIT or one MISS. Specifically, the event counts when straight line code crosses the cache line boundary, or when a branch target is on a new line.

This event is highly speculative in nature, with bytes being fetched in advance of being decoded, executed or retired. The speculation occurs in straight line code as well as in the presence of branches. Consequently, one cannot deduce ICACHE statistics by examining the number of instructions retired.  These events will not count the same as Intel Processors based on Silvermont Micro-Architecture.

These events count differently than Intel processors based on Silvermont microarchitecture.</td>
	</tr>
	<tr>
		<td><span id="ICACHE.ACCESSES">ICACHE.ACCESSES</span></td>
		<td>Counts requests to the Instruction Cache (ICache) for one or more bytes in an ICache Line.  The event strives to count on a cache line basis, so that multiple fetches to a single cache line count as one ICACHE.ACCESS.  Specifically, the event counts when accesses from straight line code crosses the cache line boundary, or when a branch target is to a new line.
This event counts differently than Intel processors based on Silvermont microarchitecture.</td>
	</tr>
	<tr>
		<td><span id="ICACHE.HIT">ICACHE.HIT</span></td>
		<td>Counts requests to the Instruction Cache (ICache) for one or more bytes in an ICache Line and that cache line is in the ICache (hit).  The event strives to count on a cache line basis, so that multiple accesses which hit in a single cache line count as one ICACHE.HIT.  Specifically, the event counts when straight line code crosses the cache line boundary, or when a branch target is to a new line, and that cache line is in the ICache. This event counts differently than Intel processors based on Silvermont microarchitecture.</td>
	</tr>
	<tr>
		<td><span id="ICACHE.MISSES">ICACHE.MISSES</span></td>
		<td>Counts requests to the Instruction Cache (ICache)  for one or more bytes in an ICache Line and that cache line is not in the ICache (miss).  The event strives to count on a cache line basis, so that multiple accesses which miss in a single cache line count as one ICACHE.MISS.  Specifically, the event counts when straight line code crosses the cache line boundary, or when a branch target is to a new line, and that cache line is not in the ICache. This event counts differently than Intel processors based on Silvermont microarchitecture.</td>
	</tr>
	<tr>
		<td><span id="INST_RETIRED.ANY">INST_RETIRED.ANY</span></td>
		<td>Counts the number of instructions that retire execution. For instructions that consist of multiple uops, this event counts the retirement of the last uop of the instruction. The counter continues counting during hardware interrupts, traps, and inside interrupt handlers.  This event uses fixed counter 0.  You cannot collect a PEBs record for this event.</td>
	</tr>
	<tr>
		<td><span id="INST_RETIRED.ANY_P">INST_RETIRED.ANY_P</span></td>
		<td>Counts the number of instructions that retire execution. For instructions that consist of multiple uops, this event counts the retirement of the last uop of the instruction. The event continues counting during hardware interrupts, traps, and inside interrupt handlers.  This is an architectural performance event.  This event uses a (_P)rogrammable general purpose performance counter. *This event is Precise Event capable:  The EventingRIP field in the PEBS record is precise to the address of the instruction which caused the event.  Note: Because PEBS records can be collected only on IA32_PMC0, only one event can use the PEBS facility at a time.</td>
	</tr>
	<tr>
		<td><span id="ISSUE_SLOTS_NOT_CONSUMED.ANY">ISSUE_SLOTS_NOT_CONSUMED.ANY</span></td>
		<td>Counts the number of issue slots per core cycle that were not consumed by the backend due to either a full resource  in the backend (RESOURCE_FULL) or due to the processor recovering from some event (RECOVERY).</td>
	</tr>
	<tr>
		<td><span id="ISSUE_SLOTS_NOT_CONSUMED.RECOVERY">ISSUE_SLOTS_NOT_CONSUMED.RECOVERY</span></td>
		<td>Counts the number of issue slots per core cycle that were not consumed by the backend because allocation is stalled waiting for a mispredicted jump to retire or other branch-like conditions (e.g. the event is relevant during certain microcode flows).   Counts all issue slots blocked while within this window including slots where uops were not available in the Instruction Queue.</td>
	</tr>
	<tr>
		<td><span id="ISSUE_SLOTS_NOT_CONSUMED.RESOURCE_FULL">ISSUE_SLOTS_NOT_CONSUMED.RESOURCE_FULL</span></td>
		<td>Counts the number of issue slots per core cycle that were not consumed because of a full resource in the backend.  Including but not limited to resources such as the Re-order Buffer (ROB), reservation stations (RS), load/store buffers, physical registers, or any other needed machine resource that is currently unavailable.   Note that uops must be available for consumption in order for this event to fire.  If a uop is not available (Instruction Queue is empty), this event will not count.</td>
	</tr>
	<tr>
		<td><span id="ITLB.MISS">ITLB.MISS</span></td>
		<td>Counts the number of times the machine was unable to find a translation in the Instruction Translation Lookaside Buffer (ITLB) for a linear address of an instruction fetch.  It counts when new translation are filled into the ITLB.  The event is speculative in nature, but will not count translations (page walks) that are begun and not finished, or translations that are finished but not filled into the ITLB.</td>
	</tr>
	<tr>
		<td><span id="L2_REJECT_XQ.ALL">L2_REJECT_XQ.ALL</span></td>
		<td>Counts the number of demand and prefetch transactions that the L2 XQ rejects due to a full or near full condition which likely indicates back pressure from the intra-die interconnect (IDI) fabric. The XQ may reject transactions from the L2Q (non-cacheable requests), L2 misses and L2 write-back victims.</td>
	</tr>
	<tr>
		<td><span id="L2Q_XQ">L2Q_XQ</span></td>
		<td>When a memory reference misses the 1st level cache, the request goes to the L2 Queue (L2Q). If the request also misses the 2nd level cache, the request is sent to the XQ, where it waits for an opportunity to be issued to the memory controller across the intra-die interconnect (IDI) fabric. Note that since the L2 is shared between a pair of processor cores, a single L2Q is shared between those two cores. Similarly, there is a single XQ for a pair of processors, situated between the L2Q and the IDI link.</td>
	</tr>
	<tr>
		<td><span id="LD_BLOCKS">LD_BLOCKS</span></td>
		<td>These events count whenever a retired load uop was blocked.  Loads can be blocked for multiple reasons including but not limited UTLB misses, blocked store forwards, 4-K aliases or other conditions.  When a load needs data that was produced (in whole or in part) from a previous store, the machine must wait until the previous store is complete.  When a load is checked against previous stores, not all of its address bits are compared to the store addresses.  This can cause a load to be blocked because its address is similar (LD_BLOCKS.4K_ALIAS) to a pending store, even though technically the load does not need to be blocked).   Under certain conditions, the machine is able to &#39;forward&#39; the data to the load from that in-progress store without waiting for the store to finish.  When conditions do not allow the load to receive data from the in-progress store, then the load is blocked until the pending store operation is complete.  LD_BLOCKS.STORE_FORWARD counts times when a load was prohibited from receiving forwarded data from the store because of address mismatch (explained below).   LD_BLOCKS.DATA_UNKOWN counts when a load is blocked from using a store forward, because the store data was not available at the right time.  A load block will not be counted as both LD_BLOCK.DATA_UNKOWN and LD_BLOCK.STORE_FORWARD. The conditions under which a load can receive data from an older store (a successful Store Forward) for this processor are that the load and store must start at the same address and the load must be the same or smaller width. (Load/store width is either 1, 2, 4, 8, or 16 bytes.). Speculative loads that don&#39;t retire but are blocked for any reason will not be counted with these events.  *These events are Precise Event capable:  The EventingRIP field in the PEBS record is precise to the address of the instruction which caused the event.  Note: Because PEBS records can be collected only on IA32_PMC0, only one event can use the PEBS facility at a time.</td>
	</tr>
	<tr>
		<td><span id="LD_BLOCKS.4K_ALIAS">LD_BLOCKS.4K_ALIAS</span></td>
		<td>Counts loads that block because their address modulo 4K matches a pending store.</td>
	</tr>
	<tr>
		<td><span id="LD_BLOCKS.ALL_BLOCK">LD_BLOCKS.ALL_BLOCK</span></td>
		<td>Counts anytime a load that retires is blocked for any reason.</td>
	</tr>
	<tr>
		<td><span id="LD_BLOCKS.DATA_UNKNOWN">LD_BLOCKS.DATA_UNKNOWN</span></td>
		<td>Counts a load blocked from using a store forward, but did not occur because the store data was not available at the right time.  The forward might occur subsequently when the data is available.</td>
	</tr>
	<tr>
		<td><span id="LD_BLOCKS.STORE_FORWARD">LD_BLOCKS.STORE_FORWARD</span></td>
		<td>Counts a load blocked from using a store forward because of an address/size mismatch, only one of the loads blocked from each store will be counted.</td>
	</tr>
	<tr>
		<td><span id="LD_BLOCKS.UTLB_MISS">LD_BLOCKS.UTLB_MISS</span></td>
		<td>Counts loads blocked because they are unable to find their physical address in the micro TLB (UTLB).</td>
	</tr>
	<tr>
		<td><span id="LONGEST_LAT_CACHE.MISS">LONGEST_LAT_CACHE.MISS</span></td>
		<td>Counts memory requests originating from the core that miss in the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="LONGEST_LAT_CACHE.REFERENCE">LONGEST_LAT_CACHE.REFERENCE</span></td>
		<td>Counts memory requests originating from the core that reference a cache line in the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="MACHINE_CLEARS">MACHINE_CLEARS</span></td>
		<td>Machine clears happen when something happens in the machine that causes the hardware to need to take special care to get the right answer.  When such a condition is signaled on an instruction, the front end of the machine is notified that it must restart, so no more instructions will be decoded from the current path.  All uops &quot;older&quot; than this one will be allowed to finish.  This uop and all &quot;younger&quot; uops must be abandoned.  Essentially, the hardware waits until the problematic uop is the oldest uop in the machine.  This means all older uops are retired.  Then, this problematic uop is discarded, and the new uops from the front end begin executing.  Machine clears can result from Self Modifying Code (SMC), Memory Ordering issues (MEMORY_ORDERING), disambiguation (DISMABIGUATION), Floating Point (FP) Assists (FP_ASSISTS) and other reasons.

(Note: most other Intel processors do not distinguish between these two types of memory ordering violations.  We make the observation that memory ordering violations are usually caused by either data shared between processors, or from from disambiguaiton.  In practice, it is often useful to know which condition causes the memory order violation.  For this reason, GLM counts machine clears due to disambiguation separatly from other memory order violation.)</td>
	</tr>
	<tr>
		<td><span id="MACHINE_CLEARS.ALL">MACHINE_CLEARS.ALL</span></td>
		<td>Counts machine clears for any reason.</td>
	</tr>
	<tr>
		<td><span id="MACHINE_CLEARS.DISAMBIGUATION">MACHINE_CLEARS.DISAMBIGUATION</span></td>
		<td>Counts machine clears due to memory disambiguation.  Memory disambiguation happens when a load which has been issued conflicts with a previous unretired store in the pipeline whose address was not known at issue time, but is later resolved to be the same as the load address.</td>
	</tr>
	<tr>
		<td><span id="MACHINE_CLEARS.FP_ASSIST">MACHINE_CLEARS.FP_ASSIST</span></td>
		<td>Counts machine clears due to floating point (FP) operations needing assists.  For instance, if the result was a floating point denormal, the hardware clears the pipeline and reissues uops to produce the correct IEEE compliant denormal result.</td>
	</tr>
	<tr>
		<td><span id="MACHINE_CLEARS.MEMORY_ORDERING">MACHINE_CLEARS.MEMORY_ORDERING</span></td>
		<td>Counts machine clears due to memory ordering issues.  This occurs when a snoop request happens and the machine is uncertain if memory ordering will be preserved as another core is in the process of modifying the data.</td>
	</tr>
	<tr>
		<td><span id="MACHINE_CLEARS.SMC">MACHINE_CLEARS.SMC</span></td>
		<td>Counts the number of times that the processor detects that a program is writing to a code section and has to perform a machine clear because of that modification.  Self-modifying code (SMC) causes a severe penalty in all Intel&#174; architecture processors.</td>
	</tr>
	<tr>
		<td><span id="MEM_LOAD_UOPS_RETIRED">MEM_LOAD_UOPS_RETIRED</span></td>
		<td>These events count when an instruction produces a uop that retrieves(loads) data, and the instruction is retired, so speculative loads are ignored.  These events report the various states of the memory hierarchy for the data being requested, which helps determine the source of latency stalls in accessing data.    *These events are Precise Event capable:  The EventingRIP field in the PEBS record is precise to the address of the instruction which caused the event.  Note: Because PEBS records can be collected only on IA32_PMC0, only one event can use the PEBS facility at a time.</td>
	</tr>
	<tr>
		<td><span id="MEM_LOAD_UOPS_RETIRED.DRAM_HIT">MEM_LOAD_UOPS_RETIRED.DRAM_HIT</span></td>
		<td>Counts memory load uops retired where the data is retrieved from DRAM.  Event is counted at retirement, so the speculative loads are ignored.  A memory load can hit (or miss) the L1 cache, hit (or miss) the L2 cache, hit DRAM, hit in the WCB or receive a HITM response.</td>
	</tr>
	<tr>
		<td><span id="MEM_LOAD_UOPS_RETIRED.HITM">MEM_LOAD_UOPS_RETIRED.HITM</span></td>
		<td>Counts load uops retired where the cache line containing the data was in the modified state of another core or modules cache (HITM).  More specifically, this means that when the load address was checked by other caching agents (typically another processor) in the system, one of those caching agents indicated that they had a dirty copy of the data.  Loads that obtain a HITM response incur greater latency than most is typical for a load.  In addition, since HITM indicates that some other processor had this data in its cache, it implies that the data was shared between processors, or potentially was a lock or semaphore value.  This event is useful for locating sharing, false sharing, and contended locks.</td>
	</tr>
	<tr>
		<td><span id="MEM_LOAD_UOPS_RETIRED.L1_HIT">MEM_LOAD_UOPS_RETIRED.L1_HIT</span></td>
		<td>Counts load uops retired that hit the L1 data cache.</td>
	</tr>
	<tr>
		<td><span id="MEM_LOAD_UOPS_RETIRED.L1_MISS">MEM_LOAD_UOPS_RETIRED.L1_MISS</span></td>
		<td>Counts load uops retired that miss the L1 data cache.</td>
	</tr>
	<tr>
		<td><span id="MEM_LOAD_UOPS_RETIRED.L2_HIT">MEM_LOAD_UOPS_RETIRED.L2_HIT</span></td>
		<td>Counts load uops retired that hit in the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="MEM_LOAD_UOPS_RETIRED.L2_MISS">MEM_LOAD_UOPS_RETIRED.L2_MISS</span></td>
		<td>Counts load uops retired that miss in the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="MEM_LOAD_UOPS_RETIRED.WCB_HIT">MEM_LOAD_UOPS_RETIRED.WCB_HIT</span></td>
		<td>Counts memory load uops retired where the data is retrieved from the WCB (or fill buffer), indicating that the load found its data while that data was in the process of being brought into the L1 cache.  Typically a load will receive this indication when some other load or prefetch missed the L1 cache and was in the process of retrieving the cache line containing the data, but that process had not yet finished (and written the data back to the cache). For example, consider load X and Y, both referencing the same cache line that is not in the L1 cache.  If load X misses cache first, it obtains and WCB (or fill buffer) and begins the process of requesting the data.  When load Y requests the data, it will either hit the WCB, or the L1 cache, depending on exactly what time the request to Y occurs.</td>
	</tr>
	<tr>
		<td><span id="MEM_UOPS_RETIRED">MEM_UOPS_RETIRED</span></td>
		<td>These events count when an instruction produces a uop that retrieves(loads) or writes(stores) data, and the instruction is retired, so speculative loads and stores are ignored.  These events also indicate if the address of memory uop misses in the Data Translation Lookaside Buffer (DTLB), the data requested spans a cache line (split), or the memory uop is a locked load: Conditions that generally require extra cycles to complete the operation.  *These events are Precise Event capable:  The EventingRIP field in the PEBS record is precise to the address of the instruction which caused the event.  Note: Because PEBS records can be collected only on IA32_PMC0, only one event can use the PEBS facility at a time.</td>
	</tr>
	<tr>
		<td><span id="MEM_UOPS_RETIRED.ALL">MEM_UOPS_RETIRED.ALL</span></td>
		<td>Counts the number of memory uops retired that is either a loads or a store or both.</td>
	</tr>
	<tr>
		<td><span id="MEM_UOPS_RETIRED.ALL_LOADS">MEM_UOPS_RETIRED.ALL_LOADS</span></td>
		<td>Counts the number of load uops retired.</td>
	</tr>
	<tr>
		<td><span id="MEM_UOPS_RETIRED.ALL_STORES">MEM_UOPS_RETIRED.ALL_STORES</span></td>
		<td>Counts the number of store uops retired.</td>
	</tr>
	<tr>
		<td><span id="MEM_UOPS_RETIRED.DTLB_MISS">MEM_UOPS_RETIRED.DTLB_MISS</span></td>
		<td>Counts uops retired that had a DTLB miss on load, store or either.  Note that when two distinct memory operations to the same page miss the DTLB, only one of them will be recorded as a DTLB miss.</td>
	</tr>
	<tr>
		<td><span id="MEM_UOPS_RETIRED.DTLB_MISS_LOADS">MEM_UOPS_RETIRED.DTLB_MISS_LOADS</span></td>
		<td>Counts load uops retired that caused a DTLB miss.</td>
	</tr>
	<tr>
		<td><span id="MEM_UOPS_RETIRED.DTLB_MISS_STORES">MEM_UOPS_RETIRED.DTLB_MISS_STORES</span></td>
		<td>Counts store uops retired that caused a DTLB miss.</td>
	</tr>
	<tr>
		<td><span id="MEM_UOPS_RETIRED.LOCK_LOADS">MEM_UOPS_RETIRED.LOCK_LOADS</span></td>
		<td>Counts locked memory uops retired.  This includes &quot;regular&quot; locks and bus locks. (To specifically count bus locks only, see the Offcore response event.)  A locked access is one with a lock prefix, or an exchange to memory.  See the SDM for a complete description of which memory load accesses are locks.</td>
	</tr>
	<tr>
		<td><span id="MEM_UOPS_RETIRED.SPLIT">MEM_UOPS_RETIRED.SPLIT</span></td>
		<td>Counts memory uops retired where the data requested spans a 64 byte cache line boundary.</td>
	</tr>
	<tr>
		<td><span id="MEM_UOPS_RETIRED.SPLIT_LOADS">MEM_UOPS_RETIRED.SPLIT_LOADS</span></td>
		<td>Counts load uops retired where the data requested spans a 64 byte cache line boundary.</td>
	</tr>
	<tr>
		<td><span id="MEM_UOPS_RETIRED.SPLIT_STORES">MEM_UOPS_RETIRED.SPLIT_STORES</span></td>
		<td>Counts store uops retired where the data requested spans a 64 byte cache line boundary.</td>
	</tr>
	<tr>
		<td><span id="MISALIGN_MEM_REF">MISALIGN_MEM_REF</span></td>
		<td>These events count when a retired memory operation spans a page boundary (a spilt).  *These events are Precise Event capable:  The EventingRIP field in the PEBS record is precise to the address of the instruction which caused the event.  Note: Because PEBS records can be collected only on IA32_PMC0, only one event can use the PEBS facility at a time.</td>
	</tr>
	<tr>
		<td><span id="MISALIGN_MEM_REF.LOAD_PAGE_SPLIT">MISALIGN_MEM_REF.LOAD_PAGE_SPLIT</span></td>
		<td>Counts when a memory load of a uop spans a page boundary (a split) is retired.</td>
	</tr>
	<tr>
		<td><span id="MISALIGN_MEM_REF.STORE_PAGE_SPLIT">MISALIGN_MEM_REF.STORE_PAGE_SPLIT</span></td>
		<td>Counts when a memory store of a uop spans a page boundary (a split) is retired.</td>
	</tr>
	<tr>
		<td><span id="MS_DECODED.MS_ENTRY">MS_DECODED.MS_ENTRY</span></td>
		<td>Counts the number of times the Microcode Sequencer (MS) starts a flow of uops from the MSROM. It does not count every time a uop is read from the MSROM.  The most common case that this counts is when a micro-coded instruction is encountered by the front end of the machine.  Other cases include when an instruction encounters a fault, trap, or microcode assist of any sort that initiates a flow of uops.  The event will count MS startups for uops that are speculative, and subsequently cleared by branch mispredict or a machine clear.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE">OFFCORE_RESPONSE</span></td>
		<td>Requires MSR_OFFCORE_RESP[0,1] to specify request type and response. (duplicated for both MSRs)</td>
	</tr>
	<tr>
		<td><span id="PAGE_WALKS">PAGE_WALKS</span></td>
		<td>These events count core cycles when a page walk is in progress.  The paging mode in use typically affects the duration of page walks.  Page walk duration divided by number of page walks is the average duration of page-walks.  The number of page walks on this processor can be determined by using the events MEM_UOPS_RETIRED.DTLB_MISS and ITLB.MISS.  The duration can hint at whether most of the page-walks are satisfied by the caches or cause an L2 cache miss.  On these events the edge trigger bit must be cleared.</td>
	</tr>
	<tr>
		<td><span id="PAGE_WALKS.CYCLES">PAGE_WALKS.CYCLES</span></td>
		<td>Counts every core cycle a page-walk is in progress due to either a data memory operation or an instruction fetch.</td>
	</tr>
	<tr>
		<td><span id="PAGE_WALKS.D_SIDE_CYCLES">PAGE_WALKS.D_SIDE_CYCLES</span></td>
		<td>Counts every core cycle when a Data-side (walks due to a data operation) page walk is in progress.</td>
	</tr>
	<tr>
		<td><span id="PAGE_WALKS.I_SIDE_CYCLES">PAGE_WALKS.I_SIDE_CYCLES</span></td>
		<td>Counts every core cycle when a Instruction-side (walks due to an instruction fetch) page walk is in progress.</td>
	</tr>
	<tr>
		<td><span id="UOPS.RETIRED">UOPS.RETIRED</span></td>
		<td>These events measure the number of retired uops.  Instructions are composed of one or more uops.  These events only count uops from instructions that retire.  A retired instruction is one that commits its state.  These events do not count when an instruction and its uops do not commit their state, and are abandoned due to mispredicted speculative execution or other reasons.  *These events are Precise Event capable:  The EventingRIP field in the PEBS record is precise to the address of the instruction which caused the event.  Note: Because PEBS records can be collected only on IA32_PMC0, only one event can use the PEBS facility at a time.</td>
	</tr>
	<tr>
		<td><span id="UOPS_ISSUED.ANY">UOPS_ISSUED.ANY</span></td>
		<td>Counts uops issued by the front end and allocated into the back end of the machine.  This event counts uops that retire as well as uops that were speculatively executed but didn&#39;t retire. The sort of speculative uops that might be counted includes, but is not limited to those uops issued in the shadow of a miss-predicted branch, those uops that are inserted during an assist (such as for a denormal floating point result), and (previously allocated) uops that might be canceled during a machine clear.</td>
	</tr>
	<tr>
		<td><span id="UOPS_NOT_DELIVERED.ANY">UOPS_NOT_DELIVERED.ANY</span></td>
		<td>This event used to measure front-end inefficiencies. I.e. when front-end of the machine is not delivering uops to the back-end and the back-end has is not stalled. This event can be used to identify if the machine is truly front-end bound.  When this event occurs, it is an indication that the front-end of the machine is operating at less than its theoretical peak performance. Background: We can think of the processor pipeline as being divided into 2 broader parts: Front-end and Back-end. Front-end is responsible for fetching the instruction, decoding into uops in machine understandable format and putting them into a uop queue to be consumed by back end. The back-end then takes these uops, allocates the required resources.  When all resources are ready, uops are executed. If the back-end is not ready to accept uops from the front-end, then we do not want to count these as front-end bottlenecks.  However, whenever we have bottlenecks in the back-end, we will have allocation unit stalls and eventually forcing the front-end to wait until the back-end is ready to receive more uops. This event counts only when back-end is requesting more uops and front-end is not able to provide them. When 3 uops are requested and no uops are delivered, the event counts 3. When 3 are requested, and only 1 is delivered, the event counts 2. When only 2 are delivered, the event counts 1. Alternatively stated, the event will not count if 3 uops are delivered, or if the back end is stalled and not requesting any uops at all.  Counts indicate missed opportunities for the front-end to deliver a uop to the back end. Some examples of conditions that cause front-end efficiencies are: ICache misses, ITLB misses, and decoder restrictions that limit the front-end bandwidth. Known Issues: Some uops require multiple allocation slots.  These uops will not be charged as a front end &#39;not delivered&#39; opportunity, and will be regarded as a back end problem. For example, the INC instruction has one uop that requires 2 issue slots.  A stream of INC instructions will not count as UOPS_NOT_DELIVERED, even though only one instruction can be issued per clock.  The low uop issue rate for a stream of INC instructions is considered to be a back end issue.</td>
	</tr>
	<tr>
		<td><span id="UOPS_RETIRED.ANY">UOPS_RETIRED.ANY</span></td>
		<td>Counts uops which retired.</td>
	</tr>
	<tr>
		<td><span id="UOPS_RETIRED.MS">UOPS_RETIRED.MS</span></td>
		<td>Counts uops retired that are from the complex flows issued by the micro-sequencer (MS).  Counts both the uops from a micro-coded instruction, and the uops that might be generated from a micro-coded assist.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_DATA_RD:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=DEMAND_DATA_RD: response=ANY_RESPONSE</span></td>
		<td>Counts demand cacheable data reads of full cache lines  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_DATA_RD:response:L2_HIT">OFFCORE_RESPONSE:request=DEMAND_DATA_RD: response=L2_HIT</span></td>
		<td>Counts demand cacheable data reads of full cache lines  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_DATA_RD:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=DEMAND_DATA_RD: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts demand cacheable data reads of full cache lines  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_DATA_RD:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=DEMAND_DATA_RD: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts demand cacheable data reads of full cache lines  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_DATA_RD:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=DEMAND_DATA_RD: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts demand cacheable data reads of full cache lines  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_DATA_RD:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=DEMAND_DATA_RD: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts demand cacheable data reads of full cache lines  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_DATA_RD:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=DEMAND_DATA_RD: response=L2_MISS.ANY</span></td>
		<td>Counts demand cacheable data reads of full cache lines  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_DATA_RD:response:OUTSTANDING">OFFCORE_RESPONSE:request=DEMAND_DATA_RD: response=OUTSTANDING</span></td>
		<td>Counts demand cacheable data reads of full cache lines  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_RFO:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=DEMAND_RFO: response=ANY_RESPONSE</span></td>
		<td>Counts demand reads for ownership (RFO) requests generated by a write to full data cache line  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_RFO:response:L2_HIT">OFFCORE_RESPONSE:request=DEMAND_RFO: response=L2_HIT</span></td>
		<td>Counts demand reads for ownership (RFO) requests generated by a write to full data cache line  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_RFO:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=DEMAND_RFO: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts demand reads for ownership (RFO) requests generated by a write to full data cache line  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_RFO:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=DEMAND_RFO: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts demand reads for ownership (RFO) requests generated by a write to full data cache line  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_RFO:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=DEMAND_RFO: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts demand reads for ownership (RFO) requests generated by a write to full data cache line  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_RFO:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=DEMAND_RFO: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts demand reads for ownership (RFO) requests generated by a write to full data cache line  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_RFO:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=DEMAND_RFO: response=L2_MISS.ANY</span></td>
		<td>Counts demand reads for ownership (RFO) requests generated by a write to full data cache line  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_RFO:response:OUTSTANDING">OFFCORE_RESPONSE:request=DEMAND_RFO: response=OUTSTANDING</span></td>
		<td>Counts demand reads for ownership (RFO) requests generated by a write to full data cache line  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_CODE_RD:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=DEMAND_CODE_RD: response=ANY_RESPONSE</span></td>
		<td>Counts demand instruction cacheline and I-side prefetch requests that miss the instruction cache  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_CODE_RD:response:L2_HIT">OFFCORE_RESPONSE:request=DEMAND_CODE_RD: response=L2_HIT</span></td>
		<td>Counts demand instruction cacheline and I-side prefetch requests that miss the instruction cache  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_CODE_RD:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=DEMAND_CODE_RD: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts demand instruction cacheline and I-side prefetch requests that miss the instruction cache  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_CODE_RD:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=DEMAND_CODE_RD: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts demand instruction cacheline and I-side prefetch requests that miss the instruction cache  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_CODE_RD:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=DEMAND_CODE_RD: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts demand instruction cacheline and I-side prefetch requests that miss the instruction cache  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_CODE_RD:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=DEMAND_CODE_RD: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts demand instruction cacheline and I-side prefetch requests that miss the instruction cache  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_CODE_RD:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=DEMAND_CODE_RD: response=L2_MISS.ANY</span></td>
		<td>Counts demand instruction cacheline and I-side prefetch requests that miss the instruction cache  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:DEMAND_CODE_RD:response:OUTSTANDING">OFFCORE_RESPONSE:request=DEMAND_CODE_RD: response=OUTSTANDING</span></td>
		<td>Counts demand instruction cacheline and I-side prefetch requests that miss the instruction cache  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:COREWB:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=COREWB: response=ANY_RESPONSE</span></td>
		<td>Counts the number of writeback transactions caused by L1 or L2 cache evictions  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:COREWB:response:L2_HIT">OFFCORE_RESPONSE:request=COREWB: response=L2_HIT</span></td>
		<td>Counts the number of writeback transactions caused by L1 or L2 cache evictions  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:COREWB:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=COREWB: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts the number of writeback transactions caused by L1 or L2 cache evictions  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:COREWB:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=COREWB: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts the number of writeback transactions caused by L1 or L2 cache evictions  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:COREWB:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=COREWB: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts the number of writeback transactions caused by L1 or L2 cache evictions  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:COREWB:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=COREWB: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts the number of writeback transactions caused by L1 or L2 cache evictions  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:COREWB:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=COREWB: response=L2_MISS.ANY</span></td>
		<td>Counts the number of writeback transactions caused by L1 or L2 cache evictions  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:COREWB:response:OUTSTANDING">OFFCORE_RESPONSE:request=COREWB: response=OUTSTANDING</span></td>
		<td>Counts the number of writeback transactions caused by L1 or L2 cache evictions  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_DATA_RD:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=PF_L2_DATA_RD: response=ANY_RESPONSE</span></td>
		<td>Counts data cacheline reads generated by hardware L2 cache prefetcher  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_DATA_RD:response:L2_HIT">OFFCORE_RESPONSE:request=PF_L2_DATA_RD: response=L2_HIT</span></td>
		<td>Counts data cacheline reads generated by hardware L2 cache prefetcher  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_DATA_RD:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=PF_L2_DATA_RD: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts data cacheline reads generated by hardware L2 cache prefetcher  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_DATA_RD:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=PF_L2_DATA_RD: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts data cacheline reads generated by hardware L2 cache prefetcher  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_DATA_RD:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=PF_L2_DATA_RD: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts data cacheline reads generated by hardware L2 cache prefetcher  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_DATA_RD:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=PF_L2_DATA_RD: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts data cacheline reads generated by hardware L2 cache prefetcher  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_DATA_RD:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=PF_L2_DATA_RD: response=L2_MISS.ANY</span></td>
		<td>Counts data cacheline reads generated by hardware L2 cache prefetcher  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_DATA_RD:response:OUTSTANDING">OFFCORE_RESPONSE:request=PF_L2_DATA_RD: response=OUTSTANDING</span></td>
		<td>Counts data cacheline reads generated by hardware L2 cache prefetcher  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_RFO:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=PF_L2_RFO: response=ANY_RESPONSE</span></td>
		<td>Counts reads for ownership (RFO) requests generated by L2 prefetcher  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_RFO:response:L2_HIT">OFFCORE_RESPONSE:request=PF_L2_RFO: response=L2_HIT</span></td>
		<td>Counts reads for ownership (RFO) requests generated by L2 prefetcher  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_RFO:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=PF_L2_RFO: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts reads for ownership (RFO) requests generated by L2 prefetcher  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_RFO:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=PF_L2_RFO: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts reads for ownership (RFO) requests generated by L2 prefetcher  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_RFO:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=PF_L2_RFO: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts reads for ownership (RFO) requests generated by L2 prefetcher  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_RFO:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=PF_L2_RFO: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts reads for ownership (RFO) requests generated by L2 prefetcher  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_RFO:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=PF_L2_RFO: response=L2_MISS.ANY</span></td>
		<td>Counts reads for ownership (RFO) requests generated by L2 prefetcher  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L2_RFO:response:OUTSTANDING">OFFCORE_RESPONSE:request=PF_L2_RFO: response=OUTSTANDING</span></td>
		<td>Counts reads for ownership (RFO) requests generated by L2 prefetcher  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_READS:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=PARTIAL_READS: response=ANY_RESPONSE</span></td>
		<td>Counts demand data partial reads, including data in uncacheable (UC) or uncacheable write combining (USWC) memory types  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_READS:response:L2_HIT">OFFCORE_RESPONSE:request=PARTIAL_READS: response=L2_HIT</span></td>
		<td>Counts demand data partial reads, including data in uncacheable (UC) or uncacheable write combining (USWC) memory types  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_READS:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=PARTIAL_READS: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts demand data partial reads, including data in uncacheable (UC) or uncacheable write combining (USWC) memory types  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_READS:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=PARTIAL_READS: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts demand data partial reads, including data in uncacheable (UC) or uncacheable write combining (USWC) memory types  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_READS:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=PARTIAL_READS: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts demand data partial reads, including data in uncacheable (UC) or uncacheable write combining (USWC) memory types  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_READS:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=PARTIAL_READS: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts demand data partial reads, including data in uncacheable (UC) or uncacheable write combining (USWC) memory types  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_READS:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=PARTIAL_READS: response=L2_MISS.ANY</span></td>
		<td>Counts demand data partial reads, including data in uncacheable (UC) or uncacheable write combining (USWC) memory types  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_READS:response:OUTSTANDING">OFFCORE_RESPONSE:request=PARTIAL_READS: response=OUTSTANDING</span></td>
		<td>Counts demand data partial reads, including data in uncacheable (UC) or uncacheable write combining (USWC) memory types  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_WRITES:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=PARTIAL_WRITES: response=ANY_RESPONSE</span></td>
		<td>Counts the number of demand write requests (RFO) generated by a write to partial data cache line, including the writes to uncacheable (UC) and write through (WT), and write protected (WP) types of memory  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_WRITES:response:L2_HIT">OFFCORE_RESPONSE:request=PARTIAL_WRITES: response=L2_HIT</span></td>
		<td>Counts the number of demand write requests (RFO) generated by a write to partial data cache line, including the writes to uncacheable (UC) and write through (WT), and write protected (WP) types of memory  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_WRITES:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=PARTIAL_WRITES: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts the number of demand write requests (RFO) generated by a write to partial data cache line, including the writes to uncacheable (UC) and write through (WT), and write protected (WP) types of memory  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_WRITES:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=PARTIAL_WRITES: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts the number of demand write requests (RFO) generated by a write to partial data cache line, including the writes to uncacheable (UC) and write through (WT), and write protected (WP) types of memory  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_WRITES:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=PARTIAL_WRITES: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts the number of demand write requests (RFO) generated by a write to partial data cache line, including the writes to uncacheable (UC) and write through (WT), and write protected (WP) types of memory  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_WRITES:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=PARTIAL_WRITES: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts the number of demand write requests (RFO) generated by a write to partial data cache line, including the writes to uncacheable (UC) and write through (WT), and write protected (WP) types of memory  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_WRITES:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=PARTIAL_WRITES: response=L2_MISS.ANY</span></td>
		<td>Counts the number of demand write requests (RFO) generated by a write to partial data cache line, including the writes to uncacheable (UC) and write through (WT), and write protected (WP) types of memory  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_WRITES:response:OUTSTANDING">OFFCORE_RESPONSE:request=PARTIAL_WRITES: response=OUTSTANDING</span></td>
		<td>Counts the number of demand write requests (RFO) generated by a write to partial data cache line, including the writes to uncacheable (UC) and write through (WT), and write protected (WP) types of memory  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:UC_CODE_RD:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=UC_CODE_RD: response=ANY_RESPONSE</span></td>
		<td>Counts code reads in uncacheable (UC) memory region  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:UC_CODE_RD:response:L2_HIT">OFFCORE_RESPONSE:request=UC_CODE_RD: response=L2_HIT</span></td>
		<td>Counts code reads in uncacheable (UC) memory region  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:UC_CODE_RD:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=UC_CODE_RD: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts code reads in uncacheable (UC) memory region  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:UC_CODE_RD:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=UC_CODE_RD: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts code reads in uncacheable (UC) memory region  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:UC_CODE_RD:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=UC_CODE_RD: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts code reads in uncacheable (UC) memory region  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:UC_CODE_RD:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=UC_CODE_RD: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts code reads in uncacheable (UC) memory region  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:UC_CODE_RD:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=UC_CODE_RD: response=L2_MISS.ANY</span></td>
		<td>Counts code reads in uncacheable (UC) memory region  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:UC_CODE_RD:response:OUTSTANDING">OFFCORE_RESPONSE:request=UC_CODE_RD: response=OUTSTANDING</span></td>
		<td>Counts code reads in uncacheable (UC) memory region  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:BUS_LOCKS:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=BUS_LOCKS: response=ANY_RESPONSE</span></td>
		<td>Counts bus lock and split lock requests  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:BUS_LOCKS:response:L2_HIT">OFFCORE_RESPONSE:request=BUS_LOCKS: response=L2_HIT</span></td>
		<td>Counts bus lock and split lock requests  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:BUS_LOCKS:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=BUS_LOCKS: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts bus lock and split lock requests  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:BUS_LOCKS:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=BUS_LOCKS: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts bus lock and split lock requests  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:BUS_LOCKS:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=BUS_LOCKS: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts bus lock and split lock requests  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:BUS_LOCKS:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=BUS_LOCKS: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts bus lock and split lock requests  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:BUS_LOCKS:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=BUS_LOCKS: response=L2_MISS.ANY</span></td>
		<td>Counts bus lock and split lock requests  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:BUS_LOCKS:response:OUTSTANDING">OFFCORE_RESPONSE:request=BUS_LOCKS: response=OUTSTANDING</span></td>
		<td>Counts bus lock and split lock requests  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:FULL_STREAMING_STORES:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=FULL_STREAMING_STORES: response=ANY_RESPONSE</span></td>
		<td>Counts full cache line data writes to uncacheable write combining (USWC) memory region and full cache-line non-temporal writes  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:FULL_STREAMING_STORES:response:L2_HIT">OFFCORE_RESPONSE:request=FULL_STREAMING_STORES: response=L2_HIT</span></td>
		<td>Counts full cache line data writes to uncacheable write combining (USWC) memory region and full cache-line non-temporal writes  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:FULL_STREAMING_STORES:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=FULL_STREAMING_STORES: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts full cache line data writes to uncacheable write combining (USWC) memory region and full cache-line non-temporal writes  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:FULL_STREAMING_STORES:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=FULL_STREAMING_STORES: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts full cache line data writes to uncacheable write combining (USWC) memory region and full cache-line non-temporal writes  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:FULL_STREAMING_STORES:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=FULL_STREAMING_STORES: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts full cache line data writes to uncacheable write combining (USWC) memory region and full cache-line non-temporal writes  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:FULL_STREAMING_STORES:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=FULL_STREAMING_STORES: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts full cache line data writes to uncacheable write combining (USWC) memory region and full cache-line non-temporal writes  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:FULL_STREAMING_STORES:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=FULL_STREAMING_STORES: response=L2_MISS.ANY</span></td>
		<td>Counts full cache line data writes to uncacheable write combining (USWC) memory region and full cache-line non-temporal writes  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:FULL_STREAMING_STORES:response:OUTSTANDING">OFFCORE_RESPONSE:request=FULL_STREAMING_STORES: response=OUTSTANDING</span></td>
		<td>Counts full cache line data writes to uncacheable write combining (USWC) memory region and full cache-line non-temporal writes  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:SW_PREFETCH:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=SW_PREFETCH: response=ANY_RESPONSE</span></td>
		<td>Counts data cache lines requests by software prefetch instructions  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:SW_PREFETCH:response:L2_HIT">OFFCORE_RESPONSE:request=SW_PREFETCH: response=L2_HIT</span></td>
		<td>Counts data cache lines requests by software prefetch instructions  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:SW_PREFETCH:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=SW_PREFETCH: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts data cache lines requests by software prefetch instructions  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:SW_PREFETCH:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=SW_PREFETCH: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts data cache lines requests by software prefetch instructions  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:SW_PREFETCH:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=SW_PREFETCH: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts data cache lines requests by software prefetch instructions  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:SW_PREFETCH:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=SW_PREFETCH: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts data cache lines requests by software prefetch instructions  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:SW_PREFETCH:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=SW_PREFETCH: response=L2_MISS.ANY</span></td>
		<td>Counts data cache lines requests by software prefetch instructions  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:SW_PREFETCH:response:OUTSTANDING">OFFCORE_RESPONSE:request=SW_PREFETCH: response=OUTSTANDING</span></td>
		<td>Counts data cache lines requests by software prefetch instructions  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L1_DATA_RD:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=PF_L1_DATA_RD: response=ANY_RESPONSE</span></td>
		<td>Counts data cache line reads generated by hardware L1 data cache prefetcher  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L1_DATA_RD:response:L2_HIT">OFFCORE_RESPONSE:request=PF_L1_DATA_RD: response=L2_HIT</span></td>
		<td>Counts data cache line reads generated by hardware L1 data cache prefetcher  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L1_DATA_RD:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=PF_L1_DATA_RD: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts data cache line reads generated by hardware L1 data cache prefetcher  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L1_DATA_RD:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=PF_L1_DATA_RD: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts data cache line reads generated by hardware L1 data cache prefetcher  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L1_DATA_RD:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=PF_L1_DATA_RD: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts data cache line reads generated by hardware L1 data cache prefetcher  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L1_DATA_RD:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=PF_L1_DATA_RD: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts data cache line reads generated by hardware L1 data cache prefetcher  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L1_DATA_RD:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=PF_L1_DATA_RD: response=L2_MISS.ANY</span></td>
		<td>Counts data cache line reads generated by hardware L1 data cache prefetcher  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PF_L1_DATA_RD:response:OUTSTANDING">OFFCORE_RESPONSE:request=PF_L1_DATA_RD: response=OUTSTANDING</span></td>
		<td>Counts data cache line reads generated by hardware L1 data cache prefetcher  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_STREAMING_STORES:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=PARTIAL_STREAMING_STORES: response=ANY_RESPONSE</span></td>
		<td>Counts partial cache line data writes to uncacheable write combining (USWC) memory region   that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_STREAMING_STORES:response:L2_HIT">OFFCORE_RESPONSE:request=PARTIAL_STREAMING_STORES: response=L2_HIT</span></td>
		<td>Counts partial cache line data writes to uncacheable write combining (USWC) memory region   that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_STREAMING_STORES:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=PARTIAL_STREAMING_STORES: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts partial cache line data writes to uncacheable write combining (USWC) memory region   that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_STREAMING_STORES:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=PARTIAL_STREAMING_STORES: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts partial cache line data writes to uncacheable write combining (USWC) memory region   that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_STREAMING_STORES:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=PARTIAL_STREAMING_STORES: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts partial cache line data writes to uncacheable write combining (USWC) memory region   that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_STREAMING_STORES:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=PARTIAL_STREAMING_STORES: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts partial cache line data writes to uncacheable write combining (USWC) memory region   that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_STREAMING_STORES:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=PARTIAL_STREAMING_STORES: response=L2_MISS.ANY</span></td>
		<td>Counts partial cache line data writes to uncacheable write combining (USWC) memory region   that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:PARTIAL_STREAMING_STORES:response:OUTSTANDING">OFFCORE_RESPONSE:request=PARTIAL_STREAMING_STORES: response=OUTSTANDING</span></td>
		<td>Counts partial cache line data writes to uncacheable write combining (USWC) memory region   that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:STREAMING_STORES:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=STREAMING_STORES: response=ANY_RESPONSE</span></td>
		<td>Counts any data writes to uncacheable write combining (USWC) memory region   that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:STREAMING_STORES:response:L2_HIT">OFFCORE_RESPONSE:request=STREAMING_STORES: response=L2_HIT</span></td>
		<td>Counts any data writes to uncacheable write combining (USWC) memory region   that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:STREAMING_STORES:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=STREAMING_STORES: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts any data writes to uncacheable write combining (USWC) memory region   that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:STREAMING_STORES:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=STREAMING_STORES: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts any data writes to uncacheable write combining (USWC) memory region   that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:STREAMING_STORES:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=STREAMING_STORES: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts any data writes to uncacheable write combining (USWC) memory region   that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:STREAMING_STORES:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=STREAMING_STORES: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts any data writes to uncacheable write combining (USWC) memory region   that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:STREAMING_STORES:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=STREAMING_STORES: response=L2_MISS.ANY</span></td>
		<td>Counts any data writes to uncacheable write combining (USWC) memory region   that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:STREAMING_STORES:response:OUTSTANDING">OFFCORE_RESPONSE:request=STREAMING_STORES: response=OUTSTANDING</span></td>
		<td>Counts any data writes to uncacheable write combining (USWC) memory region   that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_REQUEST:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=ANY_REQUEST: response=ANY_RESPONSE</span></td>
		<td>Counts requests to the uncore subsystem  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_REQUEST:response:L2_HIT">OFFCORE_RESPONSE:request=ANY_REQUEST: response=L2_HIT</span></td>
		<td>Counts requests to the uncore subsystem  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_REQUEST:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=ANY_REQUEST: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts requests to the uncore subsystem  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_REQUEST:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=ANY_REQUEST: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts requests to the uncore subsystem  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_REQUEST:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=ANY_REQUEST: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts requests to the uncore subsystem  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_REQUEST:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=ANY_REQUEST: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts requests to the uncore subsystem  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_REQUEST:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=ANY_REQUEST: response=L2_MISS.ANY</span></td>
		<td>Counts requests to the uncore subsystem  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_REQUEST:response:OUTSTANDING">OFFCORE_RESPONSE:request=ANY_REQUEST: response=OUTSTANDING</span></td>
		<td>Counts requests to the uncore subsystem  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_PF_DATA_RD:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=ANY_PF_DATA_RD: response=ANY_RESPONSE</span></td>
		<td>Counts data reads generated by L1 or L2 prefetchers  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_PF_DATA_RD:response:L2_HIT">OFFCORE_RESPONSE:request=ANY_PF_DATA_RD: response=L2_HIT</span></td>
		<td>Counts data reads generated by L1 or L2 prefetchers  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_PF_DATA_RD:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=ANY_PF_DATA_RD: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts data reads generated by L1 or L2 prefetchers  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_PF_DATA_RD:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=ANY_PF_DATA_RD: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts data reads generated by L1 or L2 prefetchers  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_PF_DATA_RD:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=ANY_PF_DATA_RD: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts data reads generated by L1 or L2 prefetchers  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_PF_DATA_RD:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=ANY_PF_DATA_RD: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts data reads generated by L1 or L2 prefetchers  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_PF_DATA_RD:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=ANY_PF_DATA_RD: response=L2_MISS.ANY</span></td>
		<td>Counts data reads generated by L1 or L2 prefetchers  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_PF_DATA_RD:response:OUTSTANDING">OFFCORE_RESPONSE:request=ANY_PF_DATA_RD: response=OUTSTANDING</span></td>
		<td>Counts data reads generated by L1 or L2 prefetchers  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_DATA_RD:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=ANY_DATA_RD: response=ANY_RESPONSE</span></td>
		<td>Counts data reads (demand &amp; prefetch)  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_DATA_RD:response:L2_HIT">OFFCORE_RESPONSE:request=ANY_DATA_RD: response=L2_HIT</span></td>
		<td>Counts data reads (demand &amp; prefetch)  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_DATA_RD:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=ANY_DATA_RD: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts data reads (demand &amp; prefetch)  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_DATA_RD:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=ANY_DATA_RD: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts data reads (demand &amp; prefetch)  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_DATA_RD:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=ANY_DATA_RD: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts data reads (demand &amp; prefetch)  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_DATA_RD:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=ANY_DATA_RD: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts data reads (demand &amp; prefetch)  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_DATA_RD:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=ANY_DATA_RD: response=L2_MISS.ANY</span></td>
		<td>Counts data reads (demand &amp; prefetch)  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_DATA_RD:response:OUTSTANDING">OFFCORE_RESPONSE:request=ANY_DATA_RD: response=OUTSTANDING</span></td>
		<td>Counts data reads (demand &amp; prefetch)  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_RFO:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=ANY_RFO: response=ANY_RESPONSE</span></td>
		<td>Counts reads for ownership (RFO) requests (demand &amp; prefetch)  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_RFO:response:L2_HIT">OFFCORE_RESPONSE:request=ANY_RFO: response=L2_HIT</span></td>
		<td>Counts reads for ownership (RFO) requests (demand &amp; prefetch)  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_RFO:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=ANY_RFO: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts reads for ownership (RFO) requests (demand &amp; prefetch)  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_RFO:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=ANY_RFO: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts reads for ownership (RFO) requests (demand &amp; prefetch)  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_RFO:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=ANY_RFO: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts reads for ownership (RFO) requests (demand &amp; prefetch)  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_RFO:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=ANY_RFO: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts reads for ownership (RFO) requests (demand &amp; prefetch)  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_RFO:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=ANY_RFO: response=L2_MISS.ANY</span></td>
		<td>Counts reads for ownership (RFO) requests (demand &amp; prefetch)  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_RFO:response:OUTSTANDING">OFFCORE_RESPONSE:request=ANY_RFO: response=OUTSTANDING</span></td>
		<td>Counts reads for ownership (RFO) requests (demand &amp; prefetch)  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_READ:response:ANY_RESPONSE">OFFCORE_RESPONSE:request=ANY_READ: response=ANY_RESPONSE</span></td>
		<td>Counts data read, code read, and read for ownership (RFO) requests (demand &amp; prefetch)  that have any transaction responses from the uncore subsystem.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_READ:response:L2_HIT">OFFCORE_RESPONSE:request=ANY_READ: response=L2_HIT</span></td>
		<td>Counts data read, code read, and read for ownership (RFO) requests (demand &amp; prefetch)  that hit the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_READ:response:L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED">OFFCORE_RESPONSE:request=ANY_READ: response=L2_MISS.SNOOP_MISS_OR_NO_SNOOP_NEEDED</span></td>
		<td>Counts data read, code read, and read for ownership (RFO) requests (demand &amp; prefetch)  that true miss for the L2 cache with a snoop miss in the other processor module. </td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_READ:response:L2_MISS.HIT_OTHER_CORE_NO_FWD">OFFCORE_RESPONSE:request=ANY_READ: response=L2_MISS.HIT_OTHER_CORE_NO_FWD</span></td>
		<td>Counts data read, code read, and read for ownership (RFO) requests (demand &amp; prefetch)  that miss the L2 cache with a snoop hit in the other processor module, no data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_READ:response:L2_MISS.HITM_OTHER_CORE">OFFCORE_RESPONSE:request=ANY_READ: response=L2_MISS.HITM_OTHER_CORE</span></td>
		<td>Counts data read, code read, and read for ownership (RFO) requests (demand &amp; prefetch)  that miss the L2 cache with a snoop hit in the other processor module, data forwarding is required.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_READ:response:L2_MISS.NON_DRAM">OFFCORE_RESPONSE:request=ANY_READ: response=L2_MISS.NON_DRAM</span></td>
		<td>Counts data read, code read, and read for ownership (RFO) requests (demand &amp; prefetch)  that miss the L2 cache and targets non-DRAM system address.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_READ:response:L2_MISS.ANY">OFFCORE_RESPONSE:request=ANY_READ: response=L2_MISS.ANY</span></td>
		<td>Counts data read, code read, and read for ownership (RFO) requests (demand &amp; prefetch)  that miss the L2 cache.</td>
	</tr>
	<tr>
		<td><span id="OFFCORE_RESPONSE:request:ANY_READ:response:OUTSTANDING">OFFCORE_RESPONSE:request=ANY_READ: response=OUTSTANDING</span></td>
		<td>Counts data read, code read, and read for ownership (RFO) requests (demand &amp; prefetch)  that outstanding, per cycle, from the time of the L2 miss to when any response is received.</td>
	</tr>
</table>

</body>
</html>
